use rand::Rng;
use std::{thread, time};
const ROWS: usize = 20;
const COLS: usize = 20;

enum Directions {
    Left,
    Right,
    Up,
    Down,
    None,
}

fn main() {
    let mut grid = [[false; ROWS]; COLS];
    grid[ROWS/2][COLS/2] = true; //setting the point that will randomly walk in every cycle of the game
    let one_second = time::Duration::from_millis(1000);
    loop {
        let direction = match rand::thread_rng().gen_range(1..5) {
            1 => Directions::Left,
            2 => Directions::Right,
            3 => Directions::Up,
            4 => Directions::Down,
            _ => Directions::None,
        };
        thread::sleep(one_second);
        print!("\x1b[2J\x1b[0;0H"); //clears the screen on Linux
        print_grid(&grid);
        update_grid(&mut grid, &direction);
    }
}

fn update_grid(arr: &mut [[bool; ROWS]; COLS], direction: &Directions) {
    for x in 1..ROWS {
        for y in 1..COLS {
            match check_neighborhood(arr, x, y) {
                true => match direction {
                    Directions::Left => {
                        arr[x-1][y] = true;
                        arr[x][y] = false;
                    },
                    Directions::Right => {
                        arr[x+1][y] = true;
                        arr[x][y] = false;
                    },
                    Directions::Up => {
                        arr[x][y-1] = true;
                        arr[x][y] = false;
                    },
                    Directions::Down => {
                        arr[x][y+1] = true;
                        arr[x][y] = false;
                    },
                    _ => {},
                },
                false => continue,
            }
        }
    }
}
fn print_grid(arr: &[[bool; ROWS]; COLS]) {
    for x in 1..ROWS {
        for y in 1..COLS {
            print!("{}", if arr[x][y] == false {
                " "
            } else {
                "o"
            })
        }
        print!("\n");
    }
}

fn check_neighborhood(arr: &[[bool;ROWS];COLS], xindex: usize, yindex: usize) -> bool {

    if xindex > 1 && yindex > 1 && xindex < ROWS - 1 && yindex < COLS - 1 {
        return arr[xindex-1][yindex] == true ||
            arr[xindex][yindex-1] == true ||
            arr[xindex+1][yindex] == true ||
            arr[xindex][yindex+1] == true

    } else {
        return false;
    }
}
